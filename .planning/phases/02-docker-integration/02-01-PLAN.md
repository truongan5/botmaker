---
phase: 02-docker-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/container.ts
  - src/services/docker-errors.ts
  - src/services/DockerService.ts
autonomous: true

must_haves:
  truths:
    - "DockerService can create container with secrets bind-mounted to /run/secrets"
    - "DockerService can start, stop, restart, and remove containers"
    - "Container status can be inspected (running/stopped/error)"
    - "Containers are labeled for BotMaker filtering (botmaker.managed=true)"
  artifacts:
    - path: "src/types/container.ts"
      provides: "ContainerStatus, ContainerInfo, ContainerConfig types"
      exports: ["ContainerStatus", "ContainerInfo", "ContainerConfig"]
    - path: "src/services/docker-errors.ts"
      provides: "ContainerError class with typed error codes"
      exports: ["ContainerError", "wrapDockerError"]
    - path: "src/services/DockerService.ts"
      provides: "Docker container lifecycle management"
      exports: ["DockerService"]
  key_links:
    - from: "src/services/DockerService.ts"
      to: "dockerode"
      via: "import Docker from 'dockerode'"
      pattern: "new Docker\\(\\)"
    - from: "src/services/DockerService.ts"
      to: "src/secrets/manager.ts"
      via: "getSecretsRoot import"
      pattern: "getSecretsRoot"
    - from: "src/services/DockerService.ts"
      to: "src/services/docker-errors.ts"
      via: "error wrapping"
      pattern: "wrapDockerError"
---

<objective>
Implement DockerService class for container lifecycle management

Purpose: Enable BotMaker to create, manage, and monitor OpenClaw bot containers
Output: TypeScript service class wrapping dockerode with proper error handling and labeling
</objective>

<execution_context>
@/home/jgarzik/.claude/get-shit-done/workflows/execute-plan.md
@/home/jgarzik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-docker-integration/02-CONTEXT.md
@.planning/phases/02-docker-integration/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing code to integrate with
@src/secrets/manager.ts
@src/types/bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create container types and error classes</name>
  <files>src/types/container.ts, src/services/docker-errors.ts</files>
  <action>
Create src/types/container.ts with:
- ContainerStatus interface: id, state ('created'|'running'|'exited'|'paused'|'restarting'|'removing'|'dead'), running (boolean), exitCode (number), startedAt (string), finishedAt (string)
- ContainerInfo interface: id, name, botId, state, status (human-readable like "Up 2 hours")
- ContainerConfig interface: image (string), environment (string[]), secretsPath (string)

Create src/services/docker-errors.ts with:
- ContainerError class extending Error with: code ('NOT_FOUND'|'ALREADY_EXISTS'|'START_FAILED'|'STOP_FAILED'|'NETWORK_ERROR'), message, botId, cause (optional Error)
- wrapDockerError(err: any, botId: string) function that maps Docker error codes:
  - statusCode 404 -> NOT_FOUND
  - statusCode 409 -> ALREADY_EXISTS
  - statusCode 304 -> ignore (not modified, container already stopped)
  - timeout/ETIMEDOUT -> NETWORK_ERROR
  - default -> START_FAILED with original message
  </action>
  <verify>npm run build succeeds with no type errors</verify>
  <done>Container types and error classes are exported and compile cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Implement DockerService</name>
  <files>src/services/DockerService.ts</files>
  <action>
Create src/services/DockerService.ts following patterns from 02-RESEARCH.md:

1. Import Docker from 'dockerode', types from container.ts, errors from docker-errors.ts, getSecretsRoot from secrets/manager.ts

2. Class DockerService with private docker: Docker initialized in constructor (uses /var/run/docker.sock by default)

3. Implement methods:

createContainer(botId: string, config: ContainerConfig): Promise<string>
- Container name: `botmaker-${botId}`
- Labels: botmaker.managed=true, botmaker.bot-id={botId}
- HostConfig: Binds secrets to /run/secrets:ro, RestartPolicy unless-stopped, NetworkMode bridge
- Env from config.environment
- Return container.id
- Wrap errors with wrapDockerError

startContainer(botId: string): Promise<void>
- Get container by name `botmaker-${botId}`
- Call container.start()
- Wrap 404 -> NOT_FOUND, already running is OK

stopContainer(botId: string): Promise<void>
- Get container, call stop({ t: 10 }) for 10s grace
- Catch 304 (already stopped) as success
- Wrap other errors

restartContainer(botId: string): Promise<void>
- Get container, call restart()
- Wrap errors

removeContainer(botId: string): Promise<void>
- Try stop first (catch 404/304)
- Then remove
- Wrap errors

getContainerStatus(botId: string): Promise<ContainerStatus | null>
- Get container, call inspect()
- Map State.Status, State.Running, State.ExitCode, State.StartedAt, State.FinishedAt
- Return null on 404 (container doesn't exist)

listManagedContainers(): Promise<ContainerInfo[]>
- listContainers with all:true, filters: { label: ['botmaker.managed=true'] }
- Map to ContainerInfo (strip leading / from name, extract botId from labels)

4. Export class as default and named export
  </action>
  <verify>npm run build succeeds; npm run lint passes</verify>
  <done>DockerService exports all 7 methods: createContainer, startContainer, stopContainer, restartContainer, removeContainer, getContainerStatus, listManagedContainers</done>
</task>

</tasks>

<verification>
- `npm run build` compiles without errors
- `npm run lint` passes
- DockerService can be imported: `import { DockerService } from './services/DockerService.js'`
- Types are properly exported from src/types/container.ts
</verification>

<success_criteria>
- ContainerStatus, ContainerInfo, ContainerConfig types exist
- ContainerError class with typed codes exists
- DockerService class implements all 7 container lifecycle methods
- All methods use proper error wrapping
- Labels include botmaker.managed=true and botmaker.bot-id
- Secrets are bind-mounted read-only to /run/secrets
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-integration/02-01-SUMMARY.md`
</output>
