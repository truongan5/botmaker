---
phase: 02-docker-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - scripts/test-docker.ts
autonomous: false

must_haves:
  truths:
    - "Container can be created and starts successfully"
    - "Container status shows running after start"
    - "Container can be stopped and removed"
    - "listManagedContainers returns created container"
  artifacts:
    - path: "scripts/test-docker.ts"
      provides: "Manual verification script for Docker integration"
  key_links:
    - from: "scripts/test-docker.ts"
      to: "src/services/DockerService.ts"
      via: "import and instantiation"
      pattern: "new DockerService"
---

<objective>
Verify DockerService works with real Docker daemon

Purpose: Confirm container lifecycle operations function correctly before API integration
Output: Verified Docker integration ready for Phase 3 API layer
</objective>

<execution_context>
@/home/jgarzik/.claude/get-shit-done/workflows/execute-plan.md
@/home/jgarzik/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-docker-integration/02-CONTEXT.md
@.planning/phases/02-docker-integration/02-01-SUMMARY.md

@src/services/DockerService.ts
@src/secrets/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker integration test script</name>
  <files>scripts/test-docker.ts</files>
  <action>
Create scripts/test-docker.ts that tests DockerService against real Docker:

1. Import DockerService, writeSecret, deleteBotSecrets, getSecretsRoot
2. Use a test bot ID (generate UUID or use fixed test ID)
3. Use alpine:latest as test image (small, fast pull)

Test sequence:
a) Write a test secret for the bot
b) Create container with alpine image, environment vars, and secrets path
c) Log container ID
d) Start container (alpine will exit immediately - that's OK)
e) Get status - should show 'exited' (alpine has no long-running process)
f) List managed containers - should include test container
g) Remove container
h) Clean up secrets
i) List again - should not include test container

Handle errors gracefully - log what failed.

Run with: npx tsx scripts/test-docker.ts
  </action>
  <verify>Script runs without crash: npx tsx scripts/test-docker.ts</verify>
  <done>Test script exercises create, start, status, list, remove operations</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>DockerService with full container lifecycle management</what-built>
  <how-to-verify>
1. Ensure Docker daemon is running: `docker info`
2. Run the test script: `npx tsx scripts/test-docker.ts`
3. Expected output shows:
   - Container created (logs container ID)
   - Container started
   - Status shows container state
   - List shows the test container with botmaker labels
   - Container removed successfully
   - Final list shows no test containers

If alpine image not cached, first run will pull it (may take 10-30s).

4. Verify no orphan containers: `docker ps -a --filter "label=botmaker.managed=true"`
   Should show no containers after test completes.
  </how-to-verify>
  <resume-signal>Type "approved" if Docker integration works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- Docker daemon accessible
- Test script runs to completion
- Container lifecycle (create -> start -> status -> list -> remove) works
- No orphan containers left after test
</verification>

<success_criteria>
- DockerService successfully creates containers with proper labels
- Containers can be started, stopped, and removed
- Status inspection returns valid container state
- listManagedContainers filters correctly by label
- No Docker-related errors in test output
</success_criteria>

<output>
After completion, create `.planning/phases/02-docker-integration/02-02-SUMMARY.md`
</output>
